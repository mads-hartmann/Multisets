<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Multisets by mads379</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Multisets</h1>
        <p>Multiset implementation in Scala</p>

        <p class="view"><a href="https://github.com/mads379/Multisets">View the Project on GitHub <small>mads379/Multisets</small></a></p>


        <ul>
          <li><a href="https://github.com/mads379/Multisets/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mads379/Multisets/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mads379/Multisets">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>Description</h3>
        <p>The collection classes in the standard library of the <a href="http://www.scala-lang.org">Scala programming language</a> has sequences, sets, maps, and several other collection types, but it does not currently have <strong>Multisets</strong>. The goal of the project is to write, document and test a complete set of APIs and implementations of Multisets that fit seamlessly into the Scala collection library. Both immutable and mutable versions of Multisets will be developed and various implementations will be compared using empirical data of their performance. The goal is to submit a SIP document adding Multisets to Scala at the end of the project and as such comprehensive testing is required.</p>
        <p>The project is by Mads Hartmann Jensen under the supervision of Ken Friis Mikkelsen (DIKU) and external supervision from Aleksandar Prokopec (EPFL).</p>
        <h3>Status</h3>
        <p>The project is still in the early stages of development so please don't use it for anything serious but please feel encouraged to try it out and suggest improvements.</p>
        <h3>Getting Started</h3>
        <p>Currently the artifacts aren't published anywhere so if you want to try it out you have to depend on the source directly from this git repository. You can do so by putting the following in your <code>project/Build.scala</code> file.</p>
        <pre><code>import sbt._

object MyProject extends Build {
  lazy val root = Project("project", file(".")) dependsOn(multi)
  lazy val multi = uri("git://github.com/mads379/Multisets")
}</code></pre>
        <p>You can find the scala-docs <a href="http://mads379.github.com/Multisets/docs/index.html">here</a></p>
        <h3>Examples</h3>
        <p>Multisets are sets that allow multiple occurrences of the same element. A distinction is made between Multisets that keep all elements in memory (<code>FullMultiset</code>) and those that store only the first of equal elements and use a counter (<code>CompactMultiset</code>) to keep track of the multiplicity of each element. This distinction is important if you have defined an equals method that does not consider all properties of the elements as you would then loose imformation if you only stored the first of equal elements.</p>
        <p>The following example shows a use-case where it makes sense to use a CompactMultiset as the equals method on <code>book</code> takes all properties into consideration, i.e. no information is lost if we just keep one object in the data structure. The program simply prints a histogram of a series of books.</p>
        <pre><code>import com.sidewayscoding.immutable.CompactListMultiset

object ShoppingCart {

  case class Book(name: String,
                  creditedTo: Option[String],
                  publisher: Option[String],
                  publicationYear: Option[Int],
                  binding: Option[String])

  def main(args: Array[String]) {

    var shoppingCart = CompactListMultiset[Book](
       Book("Brave New Words: The Oxford Dictionary of Science Fiction", Some("Jeff Prucher"), Some("Oxford University Press"), Some(2007), Some("Hardcover"))
      ,Book("On Lisp", None, Some("Prentice Hall"), Some(1993), Some("Paperback"))
      ,Book("The Logic of Failure: Why Things Go Wrong and What We Can Do to Make Them Right", None, Some("Perseus Books Group"), Some(1996), Some("Paperback"))
      ,Book("The Immaculate Conception", None, Some("House of Anansi Press"), Some(2006), None)
      ,Book("Bluebeard", Some("Kurt Vonnegut, Jr."), Some("Delacorte Press"), Some(1987), Some("Hardcover"))
      ,Book("On Lisp", None, Some("Prentice Hall"), Some(1993), Some("Paperback"))
    )

    println("Shopping cart contents")
    println((shoppingCart.multiplicities.map { case (book, count) =>
      "item %s, count: %s".format(book.name, count)
    }).mkString("\n"))

  }

}</code></pre>
<p>Another example is finding files with the same name in different directories in your hard-disk. We choose to model a file as a <code>case class</code> with the <code>filename</code> and the <code>path</code> but we define <code>equals</code> such that it only relies on the filename. In this case we don't want to use a CompactMultiset as we would loose important information (the path).</p>
<pre><code>import com.sidewayscoding.immutable.Multiset

object DuplicateFileNames {
  def main(args: Array[String]) {
      // Our custom representation of a filename.
    case class FileName(name: String, path: List[String]) {
      override def equals(o: Any) = {
        o match {
        case x: FileName => x.name == name
        case _ => false
      }
      }
    }

    val fakeDirPath = List("~", "fake", "dir")
    val tmpDirPath = List("~", "tmp", "dir")

    val folderOne = Multiset(
      FileName("log1.txt", fakeDirPath),
      FileName("log2.txt", fakeDirPath),
      FileName("log3.txt", fakeDirPath),
      FileName("log4.txt", fakeDirPath))

    val folderTwo = Multiset(
      FileName("log1.txt",tmpDirPath),
      FileName("cat-image1.jpg", tmpDirPath),
      FileName("cat-image2.jpg", tmpDirPath),
      FileName("cat-image3.jpg", tmpDirPath),
      FileName("cat-image4.jpg", tmpDirPath))

    val duplicates = folderOne intersect folderTwo

    println(duplicates.size)
    println(duplicates)
  }
}</code></pre>
        <h3>Feedback</h3>
        <p>If you have any suggestions then please open an issue on the <a href="https://github.com/mads379/Multisets">github project</a> so it can be discussed publicly.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/mads379">mads379</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-13155106-6");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>